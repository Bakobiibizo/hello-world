# !/usr/bin/env python3
# -*- coding: utf-8 -*-
# ------------------------------------------------------------------------------
#
# Copyright 2024 Richard Porteous aka Bakobiibizo
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# ------------------------------------------------------------------------------

"""
A convenience script that accepts a path to a keyfile generated by `autonomous generate-key ethereum`.

It prints the formatted `ALL_PARTICIPANTS` environment variable for running the service, ready to copy into your terminal.
"""

import argparse
import json
from typing import Dict, List


def parse_arguments() -> argparse.Namespace:
    """
    Parse command-line arguments.

    :return: Parsed arguments namespace.
    """
    parser = argparse.ArgumentParser(
        description="Sets the environment variable ALL_PARTICIPANTS from a given keypath"
    )
    parser.add_argument(
        "keypath",
        type=str,
        default=None,
        help="The relative keypath to the JSON file containing the keys you'd like to set",
    )
    return parser.parse_args()


def load_keys() -> List[Dict[str, str]]:
    """
    Load keys from a JSON file specified by the command-line argument.

    :return: A list of key dictionaries.
    :raises FileNotFoundError: If the specified file is not found.
    """
    args = parse_arguments()
    keypath = args.keypath

    try:
        with open(keypath, "r", encoding="utf-8") as f:
            list_of_keys = json.load(f)
    except FileNotFoundError as e:
        raise FileNotFoundError(f"File not found: {e}") from e

    return list_of_keys


def parse_public_keys(keys: List[Dict[str, str]]) -> List[str]:
    """
    Extract public key addresses from the list of key dictionaries.

    :param keys: List of key dictionaries.
    :return: List of public key addresses.
    """
    public_keys = []
    for key in keys:
        public_keys.append(key["address"])
    return public_keys


def construct_string(addresses: List[str]) -> str:
    """
    Construct the export command string for ALL_PARTICIPANTS environment variable.

    :param addresses: List of public key addresses.
    :return: Export command string.
    """
    value_string = ", ".join([f'"{address}"' for address in addresses])
    return f"export ALL_PARTICIPANTS='[{value_string}]'"


def main() -> None:
    """Main function to generate the export command for ALL_PARTICIPANTS."""
    loaded_keys = load_keys()
    if not loaded_keys:
        # Guard clause: exit early if no keys were loaded
        return

    public_keys = parse_public_keys(loaded_keys)
    command_string = construct_string(public_keys)
    print(f"All participants command:\n{command_string}")


if __name__ == "__main__":
    main()
